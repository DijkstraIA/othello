<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=0, shrink-to-fit=no"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta charset="UTF-8" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Last-Modified" content="0" />
    <meta http-equiv="Cache-Control" content="no-cache, mustrevalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <title>Konekti Video</title>
    <script
      type="text/javascript"
      src="https://jgomezpe.github.io/konekti/src/konekti.js"
    ></script>
    ;
  </head>

  <body>
    <script>
      Konekti.uses("header", "navbar", "canvas");

      class Agent {
        constructor() {}

        init(color, board, time = 20000) {
          this.color = color;
          this.time = time;
          this.size = board.length;
        }

        // Must return a list representing the row and column to put a piece
        // row column
        // | |
        compute(board, time) {
          return [0, 0];
        }
      }

      /*
       * A class for board operations (it is not the board but a set of operations over it)
       */
      class Board {
        constructor() {}
        // Initializes a board of the given size. A board is a matrix of size*size of characters ' ', 'B', or 'W'
        init(size) {
          var board = [];
          for (var i = 0; i < size; i++) {
            board[i] = [];
            for (var j = 0; j < size; j++) board[i][j] = " ";
          }
          var m = Math.floor(size / 2) - 1;
          board[m][m] = "W";
          board[m][m + 1] = "B";
          board[m + 1][m + 1] = "W";
          board[m + 1][m] = "B";
          return board;
        }
        // Deep clone of a board the reduce risk of damaging the real board
        clone(board) {
          var size = board.length;
          var b = [];
          for (var i = 0; i < size; i++) {
            b[i] = [];
            for (var j = 0; j < size; j++) b[i][j] = board[i][j];
          }
          return b;
        }

        // Determines if a piece of the 'color' can be set at position 'i', 'j' (row, column, respectively)
        check(board, color, i, j) {
          var size = board.length;
          if (board[i][j] != " ") return false;
          var rcolor = color == "W" ? "B" : "W";
          //left
          var k = j - 1;
          while (k >= 0 && board[i][k] == rcolor) k--;
          if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color)
            return true;
          //right
          k = j + 1;
          while (k < size && board[i][k] == rcolor) k++;
          if (k < size && Math.abs(k - j) > 1 && board[i][k] == color)
            return true;
          //up
          k = i - 1;
          while (k >= 0 && board[k][j] == rcolor) k--;
          if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color)
            return true;
          //down
          k = i + 1;
          while (k < size && board[k][j] == rcolor) k++;
          if (k < size && Math.abs(k - i) > 1 && board[k][j] == color)
            return true;
          //left-top
          k = i - 1;
          var l = j - 1;
          while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
            k--;
            l--;
          }
          if (
            k >= 0 &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //left-bottom
          k = i + 1;
          l = j - 1;
          while (k < size && l >= 0 && board[k][l] == rcolor) {
            k++;
            l--;
          }
          if (
            k < size &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //right-top
          k = i - 1;
          l = j + 1;
          while (k >= 0 && l < size && board[k][l] == rcolor) {
            k--;
            l++;
          }
          if (
            k >= 0 &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //right-bottom
          k = i + 1;
          l = j + 1;
          while (k < size && l < size && board[k][l] == rcolor) {
            k++;
            l++;
          }
          if (
            k < size &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          return false;
        }

        // Computes all the valid moves for the given 'color'
        valid_moves(board, color) {
          var moves = [];
          var size = board.length;
          for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++)
              if (this.check(board, color, i, j)) moves.push([i, j]);
          }
          return moves;
        }

        // Determines if a piece of 'color' can be set
        can_play(board, color) {
          var size = board.length;
          var i = 0;
          while (i < size) {
            var j = 0;
            while (j < size && !this.check(board, color, i, j)) j++;
            if (j < size) return true;
            i++;
          }
          return false;
        }

        // Computes the new board when a piece of 'color' is set at position 'i', 'j' (row, column respectively)
        // If it is an invalid movement stops the game and declares the other 'color' as winner
        move(board, i, j, color) {
          var white_move = color == "W";
          var size = board.length;
          if (board[i][j] != " ") return false;
          board[i][j] = color;
          var rcolor = color == "W" ? "B" : "W";
          var flag = false;
          //left
          var k = j - 1;
          while (k >= 0 && board[i][k] == rcolor) k--;
          if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color) {
            flag = true;
            k = j - 1;
            while (k > 0 && board[i][k] == rcolor) {
              board[i][k] = color;
              k--;
            }
          }
          //right
          k = j + 1;
          while (k < size && board[i][k] == rcolor) k++;
          if (k < size && Math.abs(k - j) > 1 && board[i][k] == color) {
            flag = true;
            k = j + 1;
            while (k < size && board[i][k] == rcolor) {
              board[i][k] = color;
              k++;
            }
          }
          //up
          k = i - 1;
          while (k >= 0 && board[k][j] == rcolor) k--;
          if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color) {
            flag = true;
            k = i - 1;
            while (k >= 0 && board[k][j] == rcolor) {
              board[k][j] = color;
              k--;
            }
          }
          //down
          k = i + 1;
          while (k < size && board[k][j] == rcolor) k++;
          if (k < size && Math.abs(k - i) > 1 && board[k][j] == color) {
            flag = true;
            k = i + 1;
            while (k < size && board[k][j] == rcolor) {
              board[k][j] = color;
              k++;
            }
          }
          //left-top
          k = i - 1;
          l = j - 1;
          while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
            k--;
            l--;
          }
          if (
            k >= 0 &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            k = i - 1;
            l = j - 1;
            while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
              board[k][l] = color;
              k--;
              l--;
            }
          }
          //left-bottom
          var k = i + 1;
          var l = j - 1;
          while (k < size && l >= 0 && board[k][l] == rcolor) {
            k++;
            l--;
          }
          if (
            k < size &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i + 1;
            var l = j - 1;
            while (k < size && l >= 0 && board[k][l] == rcolor) {
              board[k][l] = color;
              k++;
              l--;
            }
          }
          //right-top
          var k = i - 1;
          var l = j + 1;
          while (k >= 0 && l < size && board[k][l] == rcolor) {
            k--;
            l++;
          }
          if (
            k >= 0 &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i - 1;
            var l = j + 1;
            while (k >= 0 && l < size && board[k][l] == rcolor) {
              board[k][l] = color;
              k--;
              l++;
            }
          }
          //right-bottom
          var k = i + 1;
          var l = j + 1;
          while (k < size && l < size && board[k][l] == rcolor) {
            k++;
            l++;
          }
          if (
            k < size &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i + 1;
            var l = j + 1;
            while (k < size && l < size && board[k][l] == rcolor) {
              board[k][l] = color;
              k++;
              l++;
            }
          }
          return flag;
        }

        // Computes the winner in terms of number of pieces in the board
        winner(board, white, black) {
          var size = board.length;
          var W = 0;
          var B = 0;
          for (var i = 0; i < size; i++)
            for (var j = 0; j < size; j++)
              if (board[i][j] == "W") W++;
              else if (board[i][j] == "B") B++;
          var msg = " Pieces count W:" + W + " B:" + B;
          if (W == B) return "Draw " + msg;
          return (W > B ? white : black) + msg;
        }

        // Draw the board on the canvas
        print(board) {
          var size = board.length;
          // Commands to be run (left as string to show them into the editor)
          var grid = [];
          for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++)
              grid.push({
                command: "translate",
                y: i,
                x: j,
                commands: [{ command: "-" }, { command: board[i][j] }]
              });
          }

          var commands = {
            r: true,
            x: 1.0 / size,
            y: 1.0 / size,
            command: "fit",
            commands: grid
          };
          Konekti.client["canvas"].setText(commands);
        }
      }

      /*
       * Player's Code (Must inherit from Agent)
       * This is an example of a rangom player agent
       */

      // DIJKSTRA IA PLAYER
      class DijkstraIAPlayerLuis extends Agent {
        constructor() {
          super();
          this.board = new Board();
          //this.maxDepth = 5;
          this.memo = {};
        }

        compute(board, time) {
          let depth = this.calculateDepth(board, time);
          let bestMove = this.minimax(
            board,
            this.color,
            depth,
            -Infinity,
            Infinity
          ).move;
          return bestMove;
        }

        calculateDepth(board, remainingTime) {
          // Calculate the number of empty squares remaining
          let emptySquares = 0;
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === " ") {
                emptySquares += 1;
              }
            }
          }

          // Adjust the depth based on the size of the game board and the number of empty squares remaining
          let depth = 1;
          if (board.length <= 6) {
            depth = 8;
          } else if (board.length <= 8) {
            depth = 5;
          } else if (board.length <= 10) {
            depth = 3;
          } else {
            depth = 2;
          }
          if (emptySquares <= 10) {
            depth += 1;
          }
          if (emptySquares <= 6) {
            depth += 1;
          }

          return depth;
        }

        minimax(board, player, depth, alpha, beta) {
          let opponent = player === "W" ? "B" : "W";
          let validMoves = this.board.valid_moves(board, player);

          //Crear una clave única para el estado del juego actual
          let key = board.toString() + player + depth + alpha + beta;

          //Verificar si el valor ya se ha calculado previamente
          if (this.memo.hasOwnProperty(key)) {
            return this.memo[key];
          }

          if (depth === 0 || validMoves.length === 0) {
            return { score: this.evaluateBoard(board) };
          }

          let bestValue = {
            score: player === this.color ? -Infinity : Infinity
          };
          for (let move of validMoves) {
            let newBoard = this.board.clone(board);
            this.board.move(newBoard, move[0], move[1], player);
            let value = this.minimax(
              newBoard,
              opponent,
              depth - 1,
              alpha,
              beta
            );

            if (player === this.color) {
              if (value.score > bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              alpha = Math.max(alpha, value.score);
            } else {
              if (value.score < bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              beta = Math.min(beta, value.score);
            }

            if (alpha >= beta) break;
          }

          // Almacenar el valor en la tabla hash
          this.memo[key] = bestValue;

          return bestValue;
        }

        evaluateBoard(board) {
          let opponent = this.color === "W" ? "B" : "W";
          let myValidMoves = this.board.valid_moves(board, this.color).length;
          let opponentValidMoves = this.board.valid_moves(
            board,
            opponent
          ).length;
          let mobilityScore = myValidMoves - opponentValidMoves;
          let corners = [
            [0, 0],
            [0, board.length - 1],
            [board.length - 1, 0],
            [board.length - 1, board.length - 1]
          ];
          let blackParityAdvantage = 1;
          let whiteParityAdvantage = 1;
          let cornerWeight = 1;
          let borderWeight = 1;
          let parityWeight = 10;
          let cornerScore = 1;
          for (let corner of corners) {
            if (board[corner[0]][corner[1]] === this.color) {
              cornerScore += 1;
            } else if (board[corner[0]][corner[1]] === opponent) {
              cornerScore -= 1;
            }
          }
          let borderScore = 0;
          for (let i = 0; i < board.length; i++) {
            if (board[i][0] === this.color && !corners.includes([i, 0])) {
              borderScore += 1;
            } else if (board[i][0] === opponent && !corners.includes([i, 0])) {
              borderScore -= 1;
            }
            if (
              board[i][board.length - 1] === this.color &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore += 1;
            } else if (
              board[i][board.length - 1] === opponent &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore -= 1;
            }
            if (board[0][i] === this.color && !corners.includes([0, i])) {
              borderScore += 1;
            } else if (board[0][i] === opponent && !corners.includes([0, i])) {
              borderScore -= 1;
            }
            if (
              board[board.length - 1][i] === this.color &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore += 1;
            } else if (
              board[board.length - 1][i] === opponent &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore -= 1;
            }
          }

          let parityScore = this.estimateParity(board);
          if (this.color === "B") {
            parityScore *= blackParityAdvantage;
          } else {
            parityScore *= whiteParityAdvantage;
          }
          let weights = this.calculateWeights(board);

          return (
            mobilityScore * weights.mobilityWeight +
            cornerScore * weights.cornerWeight +
            borderScore * weights.borderWeight +
            parityScore * weights.parityWeight
          );
        }

        countEmptySquares(board) {
          let emptySquares = 0;
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === " ") {
                emptySquares += 1;
              }
            }
          }
          return emptySquares;
        }

        estimateParity(board) {
          let parityScore = 0;
          let oddRegions = this.countEmptySquares(board);
          if (oddRegions % 2 === 1) {
            parityScore += 1;
          }
          return parityScore;
        }

        calculateWeights(board) {
          let opponent = this.color === "W" ? "B" : "W";
          let weights = {
            mobilityWeight: 1,
            cornerWeight: 5,
            borderWeight: 5,
            parityWeight: 1
          };
          // Calcular la diferencia en el número de fichas entre los jugadores
          let myDisks = this.countDisks(board, this.color);
          let opponentDisks = this.countDisks(board, opponent);
          let diskDiff = myDisks - opponentDisks;
          // Ajustar los pesos en función de la diferencia en el número de fichas
          if (diskDiff > 0) {
            // Si estás ganando, dar más importancia a las estrategias defensivas
            weights.cornerWeight += diskDiff;
            weights.borderWeight += diskDiff;
            weights.parityWeight += diskDiff;
          } else if (diskDiff < 0) {
            // Si estás perdiendo, dar más importancia a las estrategias ofensivas
            weights.mobilityWeight -= diskDiff;
            weights.parityWeight -= diskDiff;
          }
          return weights;
        }

        countDisks(board, color) {
          let disks = 0;
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === color) {
                disks += 1;
              }
            }
          }
          return disks;
        }
      }
      
      ///
class DijkstraIAPlayer extends Agent {
  constructor() {
    super();
    this.board = new Board();
    this.memo = {};
  }

  compute(board, time) {
    if(time < 500){
      var moves = this.board.valid_moves(board, this.color);
      var index = Math.floor(moves.length * Math.random());
      return moves[index];
    }
    let depth = this.calculateDepth(board, time);
    let bestMove = this.minimax(
      board,
      this.color,
      depth,
      -Infinity,
      Infinity
    ).move;
    return bestMove;
  }

  calculateDepth(board, remainingTime) {
    let depth = 1;
    if (board.length <= 5) {
      depth = 10;
    }
    else if (board.length <= 6) {
      depth = 5;
    } else if (board.length <= 15) {
      depth = 3;
    } else {
      depth = 2;
    }

    if(board.length < 20){
      if(remainingTime > 8000){
        depth += 1;
      }
      if(remainingTime < 5000){
        depth = 2;
      }
    }
    else if(board.length <= 40) {
      if(remainingTime > 8000){
        depth += 1;
      }
      if(remainingTime < 10000){
        depth = 2;
      }
    }
    else{
      depth = 2;
    }

    let possibleMoves = this.board.valid_moves(board, this.color).length;
    if (possibleMoves <= 5) {
      depth += 2;
    }
    else if(possibleMoves <= 10){
      depth += 1;
    }
    else{
      depth -= 1;
    }

    
    if(board.length >= 30 && remainingTime <= 5000){
      return 1;
    }
    else if(remainingTime < 2500)
    {
      return 2;
    }
    else{
      return Math.max(depth, 2);
    }
  }

  minimax(board, player, depth, alpha, beta) {
    let opponent = player === "W" ? "B" : "W";
    let validMoves = this.board.valid_moves(board, player);
    let validMovesopponent = this.board.valid_moves(board, opponent);

    let key = board.toString() + player + depth + alpha + beta;

    if (this.memo.hasOwnProperty(key)) {
      return this.memo[key];
    }

    if (depth === 0 || (validMoves.length === 0 && validMovesopponent.length == 0)) {
      return { score: this.evaluateBoard(board) };
    }

    if(validMoves.length === 0){
      return {
          score:
            this.minimax(
            board,
            opponent,
            depth,
            alpha,
            beta
          ).score
      }
    }

    let bestValue = {
      score: player === this.color ? -Infinity : Infinity
    };
    for (let move of validMoves) {
      // let randomIndex = Math.floor(Math.random() * validMoves.length);
      // let move = validMoves[randomIndex];
      // validMoves.splice(randomIndex, 1);
      let newBoard = this.board.clone(board);
      this.board.move(newBoard, move[0], move[1], player);
      let value = this.minimax(
        newBoard,
        opponent,
        depth - 1,
        alpha,
        beta
      );

      if (player === this.color) {
        if (value.score > bestValue.score) {
          bestValue.score = value.score;
          bestValue.move = move;
        }
        alpha = Math.max(alpha, value.score);
      } else {
        if (value.score < bestValue.score) {
          bestValue.score = value.score;
          bestValue.move = move;
        }
        beta = Math.min(beta, value.score);
      }

      if (alpha > beta) break;
    }

    this.memo[key] = bestValue;

    return bestValue;
  }

  evaluateBoard(board) {
    let opponent = this.color === "W" ? "B" : "W";
    let myValidMoves = this.board.valid_moves(board, this.color).length;
    let opponentValidMoves = this.board.valid_moves(
      board,
      opponent
    ).length;
    let mobilityScore = myValidMoves - opponentValidMoves;
    let corners = [
      [0, 0],
      [0, board.length - 1],
      [board.length - 1, 0],
      [board.length - 1, board.length - 1]
    ];

    let cornerScore = 1;
    for (let corner of corners) {
      if (board[corner[0]][corner[1]] === this.color) {
        cornerScore += 1;
      } else if (board[corner[0]][corner[1]] === opponent) {
        cornerScore -= 1;
      }
    }
    let borderScore = 0;
    for (let i = 0; i < board.length; i++) {
      if (board[i][0] === this.color && !corners.includes([i, 0])) {
        borderScore += 1;
      } else if (board[i][0] === opponent && !corners.includes([i, 0])) {
        borderScore -= 1;
      }
      if (
        board[i][board.length - 1] === this.color &&
        !corners.includes([i, board.length - 1])
      ) {
        borderScore += 1;
      } else if (
        board[i][board.length - 1] === opponent &&
        !corners.includes([i, board.length - 1])
      ) {
        borderScore -= 1;
      }
      if (board[0][i] === this.color && !corners.includes([0, i])) {
        borderScore += 1;
      } else if (board[0][i] === opponent && !corners.includes([0, i])) {
        borderScore -= 1;
      }
      if (
        board[board.length - 1][i] === this.color &&
        !corners.includes([board.length - 1, i])
      ) {
        borderScore += 1;
      } else if (
        board[board.length - 1][i] === opponent &&
        !corners.includes([board.length - 1, i])
      ) {
        borderScore -= 1;
      }
    }
    
    let stabilityScore = 0
    if(mobilityScore <= -2){
        let directions = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1]
        ];
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            if (board[i][j] === this.color || board[i][j] === opponent) {
              let stable = true;
              for (let direction of directions) {
                let x = i + direction[0];
                let y = j + direction[1];
                while (
                  x >= 0 &&
                  x < board.length &&
                  y >= 0 &&
                  y < board[i].length
                ) {
                  if (board[x][y] === " ") {
                    stable = false;
                    break;
                  }
                  x += direction[0];
                  y += direction[1];
                }
                if (!stable) break;
              }
              if (stable) {
                stabilityScore += board[i][j] === this.color ? 1 : -1;
              }
            }
          }
        }
    }
    let weights = this.calculateWeights(board);
    return (
      mobilityScore * weights.mobilityWeight +
      cornerScore * weights.cornerWeight +
      borderScore * weights.borderWeight +
      stabilityScore * weights.stabilityWeight
    );
  }

  countEmptySquares(board) {
    let emptySquares = 0;
    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[i].length; j++) {
        if (board[i][j] === " ") {
          emptySquares += 1;
        }
      }
    }
    return emptySquares;
  }

  calculateStage(board) {
  let opponent = this.color === "W" ? "B" : "W";
  let stage;
  let numDisks = this.countDisks(board, this.color) + this.countDisks(board, opponent);
  let porcentaje = numDisks / (board.length * board.length);
  let low = 0.3;
  let medium = 0.5;
  if (numDisks <= low) {
    stage = 'early';
  } else if (numDisks <= medium) {
    stage = 'mid';
  } else {
    stage = 'late';
  }
  return stage;
}

  calculateWeights(board) {
    let opponent = this.color === "W" ? "B" : "W";
    let weights = {
      mobilityWeight: 1,
      stabilityWeight: 2,
      borderWeight: 3,
      cornerWeight: 4,
    };

    let myDisks = this.countDisks(board, this.color);
    let opponentDisks = this.countDisks(board, opponent);
    let diskDiff = myDisks - opponentDisks;
    let stage = this.calculateStage(board);
    let plus = 0;
    if(diskDiff < 0){
        plus = 10;
    }
    if (stage === 'early') {
      weights.mobilityWeight = 5;
      weights.stabilityWeight = 1;
      weights.borderWeight = 1 + plus;
      weights.cornerWeight = 0 + plus;
    } else if (stage === 'mid') {
      weights.mobilityWeight = 1;
      weights.stabilityWeight = 1;
      weights.borderWeight = 5 + plus;
      weights.cornerWeight = 10 + plus;
    }
    else{
      weights.mobilityWeight = 0;
      weights.stabilityWeight = 10;
      weights.borderWeight = 5 + plus;
      weights.cornerWeight = 5 + plus;
    }

    return weights;
  }

  countDisks(board, color) {
    let disks = 0;
    for (let i = 0; i < board.length; i++) {
      for (let j = 0; j < board[i].length; j++) {
        if (board[i][j] === color) {
          disks += 1;
        }
      }
    }
    return disks;
  }
}
///


      // ----- //
      class DijkstraIAPlayerENEMY extends Agent {
        constructor() {
          super();
          this.board = new Board();
          this.maxDepth = 3;
        }

        compute(board, time) {
          let bestMove = this.minimax(
            board,
            this.color,
            this.maxDepth,
            -Infinity,
            Infinity
          ).move;
          return bestMove;
        }

        minimax(board, player, depth, alpha, beta) {
          let opponent = player === "W" ? "B" : "W";
          let validMoves = this.board.valid_moves(board, player);

          if (depth === 0 || validMoves.length === 0) {
            return { score: this.evaluateBoard(board) };
          }

          let bestValue = {
            score: player === this.color ? -Infinity : Infinity
          };
          for (let move of validMoves) {
            let randomIndex = Math.floor(Math.random() * validMoves.length);
            let move = validMoves[randomIndex];
            validMoves.splice(randomIndex, 1);
            let newBoard = this.board.clone(board);
            this.board.move(newBoard, move[0], move[1], player);
            let value = this.minimax(
              newBoard,
              opponent,
              depth - 1,
              alpha,
              beta
            );

            if (player === this.color) {
              if (value.score > bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              alpha = Math.max(alpha, value.score);
            } else {
              if (value.score < bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              beta = Math.min(beta, value.score);
            }

            if (alpha >= beta) break;
          }
          return bestValue;
        }

        evaluateBoard(board) {
          let opponent = this.color === "W" ? "B" : "W";
          let myValidMoves = this.board.valid_moves(board, this.color).length;
          let opponentValidMoves = this.board.valid_moves(
            board,
            opponent
          ).length;
          let mobilityScore = myValidMoves - opponentValidMoves;

          let corners = [
            [0, 0],
            [0, board.length - 1],
            [board.length - 1, 0],
            [board.length - 1, board.length - 1]
          ];
          let cornerScore = 0;
          for (let corner of corners) {
            if (board[corner[0]][corner[1]] === this.color) {
              cornerScore += 1;
            } else if (board[corner[0]][corner[1]] === opponent) {
              cornerScore -= 1;
            }
          }

          let borderScore = 0;
          for (let i = 0; i < board.length; i++) {
            if (board[i][0] === this.color && !corners.includes([i, 0])) {
              borderScore += 1;
            } else if (board[i][0] === opponent && !corners.includes([i, 0])) {
              borderScore -= 1;
            }
            if (
              board[i][board.length - 1] === this.color &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore += 1;
            } else if (
              board[i][board.length - 1] === opponent &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore -= 1;
            }
            if (board[0][i] === this.color && !corners.includes([0, i])) {
              borderScore += 1;
            } else if (board[0][i] === opponent && !corners.includes([0, i])) {
              borderScore -= 1;
            }
            if (
              board[board.length - 1][i] === this.color &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore += 1;
            } else if (
              board[board.length - 1][i] === opponent &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore -= 1;
            }
          }

          let myCount = 0;
          let opponentCount = 0;
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === this.color) {
                myCount++;
              } else if (board[i][j] === opponent) {
                opponentCount++;
              }
            }
          }
          let parityScore = (myCount - opponentCount) % 2 === 0 ? -1 : 1;

          let stabilityScore = 0;
          let directions = [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1]
          ];
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === this.color || board[i][j] === opponent) {
                let stable = true;
                for (let direction of directions) {
                  let x = i + direction[0];
                  let y = j + direction[1];
                  while (
                    x >= 0 &&
                    x < board.length &&
                    y >= 0 &&
                    y < board[i].length
                  ) {
                    if (board[x][y] === " ") {
                      stable = false;
                      break;
                    }
                    x += direction[0];
                    y += direction[1];
                  }
                  if (!stable) break;
                }
                if (stable) {
                  stabilityScore += board[i][j] === this.color ? 1 : -1;
                }
              }
            }
          }

          return (
            parityScore +
            3 * mobilityScore +
            11 * cornerScore +
            5 * borderScore +
            stabilityScore
            // mobilityScore + 
            // 10 * cornerScore + 
            // borderScore
          );
        }
      }



      class RandomPlayer extends Agent {
        constructor() {
          super();
          this.board = new Board();
        }

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);
          var index = Math.floor(moves.length * Math.random());
          // for (var i = 0; i < 50000000; i++) {} // Making it very slow to test time restriction
          return moves[index];
        }
      }

      /*
       * Environment (Cannot be modified or any of its attributes accesed directly)
       */
      class Environment extends MainClient {
        constructor() {
          super();
          this.board = new Board();
          this.players = {
            // Here we are going to set all the players name : instance of class
            AIL: new DijkstraIAPlayerLuis(),
            AIE: new DijkstraIAPlayerENEMY(),
            AIS: new DijkstraIAPlayer(),
            rand1: new RandomPlayer(),
            rand2: new RandomPlayer()
          };
        }

        // Initializes the game
        init() {
          var white = Konekti.vc("W").value; // Name of competitor with white pieces
          var black = Konekti.vc("B").value; // Name of competitor with black pieces
          var time = 1000 * parseInt(Konekti.vc("time").value); // Maximum playing time assigned to a competitor (milliseconds)
          var size = parseInt(Konekti.vc("size").value); // Size of the reversi board

          this.size = size;
          this.b = this.board.init(size);
          this.board.print(this.b);
          var b1 = this.board.clone(this.b);
          var b2 = this.board.clone(this.b);

          this.white = white;
          this.black = black;
          this.time = { W: time, B: time };
          Konekti.vc("W_time").innerHTML = "" + time;
          Konekti.vc("B_time").innerHTML = "" + time;
          this.player = "W";
          this.winner = "";

          this.players[white].init("W", b1, time);
          this.players[black].init("B", b2, time);
        }

        // Listen to play button
        play() {
          var TIME = 10;
          var x = this;
          var board = x.board;
          x.player = "W";
          Konekti.vc("log").innerHTML = "The winner is...";

          x.init();
          var start = -1;

          function clock() {
            if (x.winner != "") return;
            if (start == -1) setTimeout(clock, TIME);
            else {
              var end = Date.now();
              var ellapsed = end - start;
              var remaining = x.time[x.player] - ellapsed;
              Konekti.vc(x.player + "_time").innerHTML = remaining;
              Konekti.vc((x.player == "W" ? "B" : "W") + "_time").innerHTML =
                x.time[x.player == "W" ? "B" : "W"];

              if (remaining <= 0)
                x.winner =
                  (x.player == "W" ? x.black : x.white) +
                  " since " +
                  (x.player == "W" ? x.white : x.black) +
                  "got time out";
              else setTimeout(clock, TIME);
            }
          }

          function compute() {
            var w = x.player == "W";
            var id = w ? x.white : x.black;
            var nid = w ? x.black : x.white;
            var b = board.clone(x.b);
            start = Date.now();
            var action = x.players[id].compute(b, x.time[x.player]);
            var end = Date.now();
            var flag = board.move(x.b, action[0], action[1], x.player);
            if (!flag) {
              x.winner =
                nid +
                " ...Invalid move taken by " +
                id +
                " on row " +
                action[0] +
                ", column " +
                action[1];
            } else {
              var ellapsed = end - start;
              x.time[x.player] -= ellapsed;
              Konekti.vc(x.player + "_time").innerHTML = "" + x.time[x.player];
              if (x.time[x.player] <= 0) {
                x.winner = nid + " since " + id + " got run of time";
              } else {
                x.player = w ? "B" : "W";
                if (!board.can_play(x.b, x.player)) {
                  x.player = w ? "W" : "B";
                  if (!board.can_play(x.b, x.player))
                    x.winner = board.winner(x.b, x.white, x.black);
                }
              }
            }

            board.print(x.b);
            start = -1;
            if (x.winner == "") setTimeout(compute, TIME);
            else Konekti.vc("log").innerHTML = "The winner is " + x.winner;
          }

          board.print(x.b);
          setTimeout(clock, 1000);
          setTimeout(compute, 1000);
        }
      }

      // Drawing commands
      function custom_commands() {
        return [
          {
            command: " ",
            commands: [
              {
                command: "fillStyle",
                color: { red: 255, green: 255, blue: 255, alpha: 255 }
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2]
              }
            ]
          },
          {
            command: "-",
            commands: [
              {
                command: "strokeStyle",
                color: { red: 0, green: 0, blue: 0, alpha: 255 }
              },
              {
                command: "polyline",
                x: [0, 0, 1, 1, 0],
                y: [0, 1, 1, 0, 0]
              }
            ]
          },
          {
            command: "B",
            commands: [
              {
                command: "fillStyle",
                color: { red: 0, green: 0, blue: 0, alpha: 255 }
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2]
              }
            ]
          },
          {
            command: "W",
            commands: [
              {
                command: "fillStyle",
                color: { red: 255, green: 255, blue: 0, alpha: 255 }
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2]
              }
            ]
          }
        ];
      }

      // Main function using the Konekti infrastructure
      function KonektiMain() {
        var client = new Environment();
        Konekti.header("title", "", "Reversi", 3, {
          class: "w3-black w3-center"
        });
        Konekti.raw("log", "The winner is...");
        // Connects the video with the HTML component
        var btn2 = [
          {
            plugin: "raw",
            setup: [
              "time",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf252; Time (secs)",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "size",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf00a; Size",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "W",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf10c; White",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "W_time",
              "&#xf252; White",
              {
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "B",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf111; Black",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "B_time",
              "&#xf252; Black",
              {
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "btn",
            setup: [
              "play",
              "fa-play",
              "",
              null,
              { title: "Cara", class: "w3-right" }
            ]
          }
        ];
        Konekti.navbar(
          "navbar2",
          btn2,
          { client: "client", method: "play" },
          { class: "w3-black w3-medium" }
        );
        // Connecting the canvas to the HTML component
        var commands = custom_commands();
        Konekti.canvas("canvas", {}, commands, {
          width: "100%",
          height: "fit"
        });
      }
    </script>
  </body>
</html>
