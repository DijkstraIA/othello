<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=0, shrink-to-fit=no"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta charset="UTF-8" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Last-Modified" content="0" />
    <meta http-equiv="Cache-Control" content="no-cache, mustrevalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <title>Konekti Video</title>
    <script
      type="text/javascript"
      src="https://jgomezpe.github.io/konekti/src/konekti.js"
    ></script>
    ;
  </head>

  <body>
    <script>
      Konekti.uses("header", "navbar", "canvas");

      class Agent {
        constructor() {}

        init(color, board, time = 20000) {
          this.color = color;
          this.time = time;
          this.size = board.length;
        }

        // Must return a list representing the row and column to put a piece
        // row column
        // | |
        compute(board, time) {
          return [0, 0];
        }
      }

      /*
       * A class for board operations (it is not the board but a set of operations over it)
       */
      class Board {
        constructor() {}
        // Initializes a board of the given size. A board is a matrix of size*size of characters ' ', 'B', or 'W'
        init(size) {
          var board = [];
          for (var i = 0; i < size; i++) {
            board[i] = [];
            for (var j = 0; j < size; j++) board[i][j] = " ";
          }
          var m = Math.floor(size / 2) - 1;
          board[m][m] = "W";
          board[m][m + 1] = "B";
          board[m + 1][m + 1] = "W";
          board[m + 1][m] = "B";
          return board;
        }
        // Deep clone of a board the reduce risk of damaging the real board
        clone(board) {
          var size = board.length;
          var b = [];
          for (var i = 0; i < size; i++) {
            b[i] = [];
            for (var j = 0; j < size; j++) b[i][j] = board[i][j];
          }
          return b;
        }

        // Determines if a piece of the 'color' can be set at position 'i', 'j' (row, column, respectively)
        check(board, color, i, j) {
          var size = board.length;
          if (board[i][j] != " ") return false;
          var rcolor = color == "W" ? "B" : "W";
          //left
          var k = j - 1;
          while (k >= 0 && board[i][k] == rcolor) k--;
          if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color)
            return true;
          //right
          k = j + 1;
          while (k < size && board[i][k] == rcolor) k++;
          if (k < size && Math.abs(k - j) > 1 && board[i][k] == color)
            return true;
          //up
          k = i - 1;
          while (k >= 0 && board[k][j] == rcolor) k--;
          if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color)
            return true;
          //down
          k = i + 1;
          while (k < size && board[k][j] == rcolor) k++;
          if (k < size && Math.abs(k - i) > 1 && board[k][j] == color)
            return true;
          //left-top
          k = i - 1;
          var l = j - 1;
          while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
            k--;
            l--;
          }
          if (
            k >= 0 &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //left-bottom
          k = i + 1;
          l = j - 1;
          while (k < size && l >= 0 && board[k][l] == rcolor) {
            k++;
            l--;
          }
          if (
            k < size &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //right-top
          k = i - 1;
          l = j + 1;
          while (k >= 0 && l < size && board[k][l] == rcolor) {
            k--;
            l++;
          }
          if (
            k >= 0 &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //right-bottom
          k = i + 1;
          l = j + 1;
          while (k < size && l < size && board[k][l] == rcolor) {
            k++;
            l++;
          }
          if (
            k < size &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          return false;
        }

        // Computes all the valid moves for the given 'color'
        valid_moves(board, color) {
          var moves = [];
          var size = board.length;
          for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++)
              if (this.check(board, color, i, j)) moves.push([i, j]);
          }
          return moves;
        }

        // Determines if a piece of 'color' can be set
        can_play(board, color) {
          var size = board.length;
          var i = 0;
          while (i < size) {
            var j = 0;
            while (j < size && !this.check(board, color, i, j)) j++;
            if (j < size) return true;
            i++;
          }
          return false;
        }

        // Computes the new board when a piece of 'color' is set at position 'i', 'j' (row, column respectively)
        // If it is an invalid movement stops the game and declares the other 'color' as winner
        move(board, i, j, color) {
          var white_move = color == "W";
          var size = board.length;
          if (board[i][j] != " ") return false;
          board[i][j] = color;
          var rcolor = color == "W" ? "B" : "W";
          var flag = false;
          //left
          var k = j - 1;
          while (k >= 0 && board[i][k] == rcolor) k--;
          if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color) {
            flag = true;
            k = j - 1;
            while (k > 0 && board[i][k] == rcolor) {
              board[i][k] = color;
              k--;
            }
          }
          //right
          k = j + 1;
          while (k < size && board[i][k] == rcolor) k++;
          if (k < size && Math.abs(k - j) > 1 && board[i][k] == color) {
            flag = true;
            k = j + 1;
            while (k < size && board[i][k] == rcolor) {
              board[i][k] = color;
              k++;
            }
          }
          //up
          k = i - 1;
          while (k >= 0 && board[k][j] == rcolor) k--;
          if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color) {
            flag = true;
            k = i - 1;
            while (k >= 0 && board[k][j] == rcolor) {
              board[k][j] = color;
              k--;
            }
          }
          //down
          k = i + 1;
          while (k < size && board[k][j] == rcolor) k++;
          if (k < size && Math.abs(k - i) > 1 && board[k][j] == color) {
            flag = true;
            k = i + 1;
            while (k < size && board[k][j] == rcolor) {
              board[k][j] = color;
              k++;
            }
          }
          //left-top
          k = i - 1;
          l = j - 1;
          while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
            k--;
            l--;
          }
          if (
            k >= 0 &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            k = i - 1;
            l = j - 1;
            while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
              board[k][l] = color;
              k--;
              l--;
            }
          }
          //left-bottom
          var k = i + 1;
          var l = j - 1;
          while (k < size && l >= 0 && board[k][l] == rcolor) {
            k++;
            l--;
          }
          if (
            k < size &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i + 1;
            var l = j - 1;
            while (k < size && l >= 0 && board[k][l] == rcolor) {
              board[k][l] = color;
              k++;
              l--;
            }
          }
          //right-top
          var k = i - 1;
          var l = j + 1;
          while (k >= 0 && l < size && board[k][l] == rcolor) {
            k--;
            l++;
          }
          if (
            k >= 0 &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i - 1;
            var l = j + 1;
            while (k >= 0 && l < size && board[k][l] == rcolor) {
              board[k][l] = color;
              k--;
              l++;
            }
          }
          //right-bottom
          var k = i + 1;
          var l = j + 1;
          while (k < size && l < size && board[k][l] == rcolor) {
            k++;
            l++;
          }
          if (
            k < size &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i + 1;
            var l = j + 1;
            while (k < size && l < size && board[k][l] == rcolor) {
              board[k][l] = color;
              k++;
              l++;
            }
          }
          return flag;
        }

        // Computes the winner in terms of number of pieces in the board
        winner(board, white, black) {
          var size = board.length;
          var W = 0;
          var B = 0;
          for (var i = 0; i < size; i++)
            for (var j = 0; j < size; j++)
              if (board[i][j] == "W") W++;
              else if (board[i][j] == "B") B++;
          var msg = " Pieces count W:" + W + " B:" + B;
          if (W == B) return "Draw " + msg;
          return (W > B ? white : black) + msg;
        }

        // Draw the board on the canvas
        print(board) {
          var size = board.length;
          // Commands to be run (left as string to show them into the editor)
          var grid = [];
          for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++)
              grid.push({
                command: "translate",
                y: i,
                x: j,
                commands: [{ command: "-" }, { command: board[i][j] }]
              });
          }

          var commands = {
            r: true,
            x: 1.0 / size,
            y: 1.0 / size,
            command: "fit",
            commands: grid
          };
          Konekti.client["canvas"].setText(commands);
        }
      }

      /*
       * Player's Code (Must inherit from Agent)
       * This is an example of a rangom player agent
       */
      class MinMax {
        constructor() {
          this.board = new Board();
          this.INF = 1000000000.0;
        }

        // FUNCIÓN DE EVALUACIÓN
        funct(board, color, myColor) {
          let totalPoints = 0;
          const rcolor = color === "W" ? "B" : "W";

          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === color) {
                totalPoints++;
              } else if (board[i][j] === rcolor) {
                totalPoints--;
              }
            }
          }

          totalPoints += this.calculatePoints3(board, color, myColor);

          // Ajusta el puntaje si el jugador es el jugador actual (myColor)
          if (color === myColor) {
            return totalPoints;
          } else {
            return -totalPoints;
          }
        }
        // Calculo por esquinas
        calculatePoints3(board, color, myColor) {
          const cornerPoints = {
            W: color == "W" ? 3 : -3, // Puntos para el jugador X por cada esquina ocupada
            B: color == "B" ? 3 : -3 // Puntos para el jugador O por cada esquina ocupada
          };
          let totalPoints = 0;
          const n = board.length - 1;
          // Comprobar las cuatro esquinas del tablero
          if (board[0][0] === color) {
            totalPoints += cornerPoints[color];
          }
          if (board[0][n] === color) {
            totalPoints += cornerPoints[color];
          }
          if (board[n][0] === color) {
            totalPoints += cornerPoints[color];
          }
          if (board[n][n] === color) {
            totalPoints += cornerPoints[color];
          }

          return totalPoints;
        }
        // Fin de evaluacion de tablero

        algorithm(board, depht, alpha, beta, maximizing, color, myColor) {
          var rcolor = color === "W" ? "B" : "W";

          // TODO: Add a better evaluation function
          var moves = this.board.valid_moves(board, color);
          var rmoves = this.board.valid_moves(board, rcolor);
          if (depht === 0 || (moves.length === 0 && rmoves.length === 0)) {
            const valGame = this.funct(board, color, myColor);
            return valGame;
          }
          if (moves.length === 0) {
            return this.algorithm(
              board,
              depht - 1,
              alpha,
              beta,
              maximizing ? false : true,
              rcolor,
              myColor
            );
          }

          if (maximizing) {
            var best = -this.INF;
            for (var i = 0; i < moves.length; i++) {
              var newBoard = this.board.clone(board);
              this.board.move(newBoard, moves[i][0], moves[i][1], color);
              best = Math.max(
                best,
                this.algorithm(
                  newBoard,
                  depht - 1,
                  alpha,
                  beta,
                  false,
                  rcolor,
                  myColor
                )
              );
              if (best > beta) break;
              alpha = Math.max(alpha, best);
            }
            return best;
          } else {
            var best = this.INF;
            for (var i = 0; i < moves.length; i++) {
              var newBoard = this.board.clone(board);
              this.board.move(newBoard, moves[i][0], moves[i][1], color);
              best = Math.min(
                best,
                this.algorithm(
                  newBoard,
                  depht - 1,
                  alpha,
                  beta,
                  true,
                  rcolor,
                  myColor
                )
              );
              if (best < alpha) break;
              beta = Math.min(beta, best);
            }
            return best;
          }
        }
        findBestMove(board, color, maxDepth) {
          var best = -this.INF;
          var moves = this.board.valid_moves(board, color);
          var bestMove = moves[0];
          var rcolor = color == "W" ? "B" : "W";
          for (var i = 0; i < moves.length; i++) {
            var newBoard = this.board.clone(board);
            this.board.move(newBoard, moves[i][0], moves[i][1], color);
            var value = this.algorithm(
              newBoard,
              maxDepth,
              -this.INF,
              this.INF,
              false,
              rcolor,
              color
            );
            if (value > best) {
              best = value;
              bestMove = moves[i];
            }
          }
          return bestMove;
        }
      }

      class DijkstraIAPlayerSEBASTIAN extends Agent {
        constructor() {
          super();
          this.board = new Board();
          this.algorithm = new MinMax();
        }

        calculateDepth(board, remainingTime) {
          const timeLimit = this.time;
          const possibleMoves = this.board.valid_moves(board, this.color);
          let depth = 1;
          if (board.length == 4) depth = 200;
          else if (board.length == 8) depth = 5;
          else if (board.length == 20) depth = 3;
          else depth = 1;
          return depth;
        }

        compute(board, time) {
          // TODO: Add a better calculateDepth function
          var depth = this.calculateDepth(board, time);

          this.algorithm.color = this.color;
          var moves = this.algorithm.findBestMove(board, this.color, depth);
          return moves;
        }
      }
      // DIJKSTRA IA PLAYER
      class DijkstraIAPlayerLUIS extends Agent {
        constructor() {
          super();
          this.board = new Board();
          this.maxDepth = 5;
        }

        compute(board, time) {
          let bestMove = this.minimax(
            board,
            this.color,
            this.maxDepth,
            -Infinity,
            Infinity
          ).move;
          return bestMove;
        }

        minimax(board, player, depth, alpha, beta) {
          let opponent = player === "W" ? "B" : "W";
          let validMoves = this.board.valid_moves(board, player);

          if (depth === 0 || validMoves.length === 0) {
            return { score: this.evaluateBoard(board) };
          }

          let bestValue = {
            score: player === this.color ? -Infinity : Infinity
          };
          for (let move of validMoves) {
            let newBoard = this.board.clone(board);
            this.board.move(newBoard, move[0], move[1], player);
            let value = this.minimax(
              newBoard,
              opponent,
              depth - 1,
              alpha,
              beta
            );

            if (player === this.color) {
              if (value.score > bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              alpha = Math.max(alpha, value.score);
            } else {
              if (value.score < bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              beta = Math.min(beta, value.score);
            }

            if (alpha >= beta) break;
          }
          return bestValue;
        }

        evaluateBoard(board) {
          let opponent = this.color === "W" ? "B" : "W";
          let myValidMoves = this.board.valid_moves(board, this.color).length;
          let opponentValidMoves = this.board.valid_moves(
            board,
            opponent
          ).length;
          let mobilityScore = myValidMoves - opponentValidMoves;

          let corners = [
            [0, 0],
            [0, board.length - 1],
            [board.length - 1, 0],
            [board.length - 1, board.length - 1]
          ];
          let cornerScore = 0;
          for (let corner of corners) {
            if (board[corner[0]][corner[1]] === this.color) {
              cornerScore += 1;
            } else if (board[corner[0]][corner[1]] === opponent) {
              cornerScore -= 1;
            }
          }

          let borderScore = 0;
          for (let i = 0; i < board.length; i++) {
            if (board[i][0] === this.color && !corners.includes([i, 0])) {
              borderScore += 1;
            } else if (board[i][0] === opponent && !corners.includes([i, 0])) {
              borderScore -= 1;
            }
            if (
              board[i][board.length - 1] === this.color &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore += 1;
            } else if (
              board[i][board.length - 1] === opponent &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore -= 1;
            }
            if (board[0][i] === this.color && !corners.includes([0, i])) {
              borderScore += 1;
            } else if (board[0][i] === opponent && !corners.includes([0, i])) {
              borderScore -= 1;
            }
            if (
              board[board.length - 1][i] === this.color &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore += 1;
            } else if (
              board[board.length - 1][i] === opponent &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore -= 1;
            }
          }

          return mobilityScore + 10 * cornerScore + borderScore;
        }
      }
      // ----- //
      class DijkstraIAPlayerLUIS2 extends Agent {
        constructor() {
          super();
          this.board = new Board();
          this.maxDepth = 7;
        }

        compute(board, time) {
          let bestMove = this.minimax(
            board,
            this.color,
            this.maxDepth,
            -Infinity,
            Infinity
          ).move;
          return bestMove;
        }

        minimax(board, player, depth, alpha, beta) {
          let opponent = player === "W" ? "B" : "W";
          let validMoves = this.board.valid_moves(board, player);

          if (depth === 0 || validMoves.length === 0) {
            return { score: this.evaluateBoard(board) };
          }

          let bestValue = {
            score: player === this.color ? -Infinity : Infinity
          };
          for (let move of validMoves) {
            let randomIndex = Math.floor(Math.random() * validMoves.length);
            let move = validMoves[randomIndex];
            validMoves.splice(randomIndex, 1);
            let newBoard = this.board.clone(board);
            this.board.move(newBoard, move[0], move[1], player);
            let value = this.minimax(
              newBoard,
              opponent,
              depth - 1,
              alpha,
              beta
            );

            if (player === this.color) {
              if (value.score > bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              alpha = Math.max(alpha, value.score);
            } else {
              if (value.score < bestValue.score) {
                bestValue.score = value.score;
                bestValue.move = move;
              }
              beta = Math.min(beta, value.score);
            }

            if (alpha >= beta) break;
          }
          return bestValue;
        }

        evaluateBoard(board) {
          let opponent = this.color === "W" ? "B" : "W";
          let myValidMoves = this.board.valid_moves(board, this.color).length;
          let opponentValidMoves = this.board.valid_moves(
            board,
            opponent
          ).length;
          let mobilityScore = myValidMoves - opponentValidMoves;

          let corners = [
            [0, 0],
            [0, board.length - 1],
            [board.length - 1, 0],
            [board.length - 1, board.length - 1]
          ];
          let cornerScore = 0;
          for (let corner of corners) {
            if (board[corner[0]][corner[1]] === this.color) {
              cornerScore += 1;
            } else if (board[corner[0]][corner[1]] === opponent) {
              cornerScore -= 1;
            }
          }

          let borderScore = 0;
          for (let i = 0; i < board.length; i++) {
            if (board[i][0] === this.color && !corners.includes([i, 0])) {
              borderScore += 1;
            } else if (board[i][0] === opponent && !corners.includes([i, 0])) {
              borderScore -= 1;
            }
            if (
              board[i][board.length - 1] === this.color &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore += 1;
            } else if (
              board[i][board.length - 1] === opponent &&
              !corners.includes([i, board.length - 1])
            ) {
              borderScore -= 1;
            }
            if (board[0][i] === this.color && !corners.includes([0, i])) {
              borderScore += 1;
            } else if (board[0][i] === opponent && !corners.includes([0, i])) {
              borderScore -= 1;
            }
            if (
              board[board.length - 1][i] === this.color &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore += 1;
            } else if (
              board[board.length - 1][i] === opponent &&
              !corners.includes([board.length - 1, i])
            ) {
              borderScore -= 1;
            }
          }

          let myCount = 0;
          let opponentCount = 0;
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === this.color) {
                myCount++;
              } else if (board[i][j] === opponent) {
                opponentCount++;
              }
            }
          }
          let parityScore = (myCount - opponentCount) % 2 === 0 ? -1 : 1;

          let stabilityScore = 0;
          let directions = [
            [-1, -1],
            [-1, 0],
            [-1, 1],
            [0, -1],
            [0, 1],
            [1, -1],
            [1, 0],
            [1, 1]
          ];
          for (let i = 0; i < board.length; i++) {
            for (let j = 0; j < board[i].length; j++) {
              if (board[i][j] === this.color || board[i][j] === opponent) {
                let stable = true;
                for (let direction of directions) {
                  let x = i + direction[0];
                  let y = j + direction[1];
                  while (
                    x >= 0 &&
                    x < board.length &&
                    y >= 0 &&
                    y < board[i].length
                  ) {
                    if (board[x][y] === " ") {
                      stable = false;
                      break;
                    }
                    x += direction[0];
                    y += direction[1];
                  }
                  if (!stable) break;
                }
                if (stable) {
                  stabilityScore += board[i][j] === this.color ? 1 : -1;
                }
              }
            }
          }

          return (
            parityScore +
            3 * mobilityScore +
            11 * cornerScore +
            5 * borderScore +
            stabilityScore
          );

          // let opponent = this.color === "W" ? "B" : "W";
          // let myValidMoves = this.board.valid_moves(board, this.color).length;
          // let opponentValidMoves = this.board.valid_moves(
          //   board,
          //   opponent
          // ).length;
          // let mobilityScore = myValidMoves - opponentValidMoves;
          // let corners = [
          //   [0, 0],
          //   [0, board.length - 1],
          //   [board.length - 1, 0],
          //   [board.length - 1, board.length - 1]
          // ];
          // let cornerScore = 0;
          // for (let corner of corners) {
          //   if (board[corner[0]][corner[1]] === this.color) {
          //     cornerScore += 1;
          //   } else if (board[corner[0]][corner[1]] === opponent) {
          //     cornerScore -= 1;
          //   }
          // }
          // let borderScore = 0;
          // for (let i = 0; i < board.length; i++) {
          //   if (board[i][0] === this.color && !corners.includes([i, 0])) {
          //     borderScore += 1;
          //   } else if (board[i][0] === opponent && !corners.includes([i, 0])) {
          //     borderScore -= 1;
          //   }
          //   if (
          //     board[i][board.length - 1] === this.color &&
          //     !corners.includes([i, board.length - 1])
          //   ) {
          //     borderScore += 1;
          //   } else if (
          //     board[i][board.length - 1] === opponent &&
          //     !corners.includes([i, board.length - 1])
          //   ) {
          //     borderScore -= 1;
          //   }
          //   if (board[0][i] === this.color && !corners.includes([0, i])) {
          //     borderScore += 1;
          //   } else if (board[0][i] === opponent && !corners.includes([0, i])) {
          //     borderScore -= 1;
          //   }
          //   if (
          //     board[board.length - 1][i] === this.color &&
          //     !corners.includes([board.length - 1, i])
          //   ) {
          //     borderScore += 1;
          //   } else if (
          //     board[board.length - 1][i] === opponent &&
          //     !corners.includes([board.length - 1, i])
          //   ) {
          //     borderScore -= 1;
          //   }
          // }
          // return mobilityScore + 10 * cornerScore + borderScore;
        }
      }

      class RandomPlayer extends Agent {
        constructor() {
          super();
          this.board = new Board();
        }

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);
          var index = Math.floor(moves.length * Math.random());
          for (var i = 0; i < 50000000; i++) {} // Making it very slow to test time restriction
          return moves[index];
        }
      }

      /*
       * Environment (Cannot be modified or any of its attributes accesed directly)
       */
      class Environment extends MainClient {
        constructor() {
          super();
          this.board = new Board();
          this.players = {
            // Here we are going to set all the players name : instance of class
            AIL: new DijkstraIAPlayerLUIS(),
            AIS: new DijkstraIAPlayerLUIS2(),
            rand1: new RandomPlayer(),
            rand2: new RandomPlayer()
          };
        }

        // Initializes the game
        init() {
          var white = Konekti.vc("W").value; // Name of competitor with white pieces
          var black = Konekti.vc("B").value; // Name of competitor with black pieces
          var time = 1000 * parseInt(Konekti.vc("time").value); // Maximum playing time assigned to a competitor (milliseconds)
          var size = parseInt(Konekti.vc("size").value); // Size of the reversi board

          this.size = size;
          this.b = this.board.init(size);
          this.board.print(this.b);
          var b1 = this.board.clone(this.b);
          var b2 = this.board.clone(this.b);

          this.white = white;
          this.black = black;
          this.time = { W: time, B: time };
          Konekti.vc("W_time").innerHTML = "" + time;
          Konekti.vc("B_time").innerHTML = "" + time;
          this.player = "W";
          this.winner = "";

          this.players[white].init("W", b1, time);
          this.players[black].init("B", b2, time);
        }

        // Listen to play button
        play() {
          var TIME = 10;
          var x = this;
          var board = x.board;
          x.player = "W";
          Konekti.vc("log").innerHTML = "The winner is...";

          x.init();
          var start = -1;

          function clock() {
            if (x.winner != "") return;
            if (start == -1) setTimeout(clock, TIME);
            else {
              var end = Date.now();
              var ellapsed = end - start;
              var remaining = x.time[x.player] - ellapsed;
              Konekti.vc(x.player + "_time").innerHTML = remaining;
              Konekti.vc((x.player == "W" ? "B" : "W") + "_time").innerHTML =
                x.time[x.player == "W" ? "B" : "W"];

              if (remaining <= 0)
                x.winner =
                  (x.player == "W" ? x.black : x.white) +
                  " since " +
                  (x.player == "W" ? x.white : x.black) +
                  "got time out";
              else setTimeout(clock, TIME);
            }
          }

          function compute() {
            var w = x.player == "W";
            var id = w ? x.white : x.black;
            var nid = w ? x.black : x.white;
            var b = board.clone(x.b);
            start = Date.now();
            var action = x.players[id].compute(b, x.time[x.player]);
            var end = Date.now();
            var flag = board.move(x.b, action[0], action[1], x.player);
            if (!flag) {
              x.winner =
                nid +
                " ...Invalid move taken by " +
                id +
                " on row " +
                action[0] +
                ", column " +
                action[1];
            } else {
              var ellapsed = end - start;
              x.time[x.player] -= ellapsed;
              Konekti.vc(x.player + "_time").innerHTML = "" + x.time[x.player];
              if (x.time[x.player] <= 0) {
                x.winner = nid + " since " + id + " got run of time";
              } else {
                x.player = w ? "B" : "W";
                if (!board.can_play(x.b, x.player)) {
                  x.player = w ? "W" : "B";
                  if (!board.can_play(x.b, x.player))
                    x.winner = board.winner(x.b, x.white, x.black);
                }
              }
            }

            board.print(x.b);
            start = -1;
            if (x.winner == "") setTimeout(compute, TIME);
            else Konekti.vc("log").innerHTML = "The winner is " + x.winner;
          }

          board.print(x.b);
          setTimeout(clock, 1000);
          setTimeout(compute, 1000);
        }
      }

      // Drawing commands
      function custom_commands() {
        return [
          {
            command: " ",
            commands: [
              {
                command: "fillStyle",
                color: { red: 255, green: 255, blue: 255, alpha: 255 }
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2]
              }
            ]
          },
          {
            command: "-",
            commands: [
              {
                command: "strokeStyle",
                color: { red: 0, green: 0, blue: 0, alpha: 255 }
              },
              {
                command: "polyline",
                x: [0, 0, 1, 1, 0],
                y: [0, 1, 1, 0, 0]
              }
            ]
          },
          {
            command: "B",
            commands: [
              {
                command: "fillStyle",
                color: { red: 0, green: 0, blue: 0, alpha: 255 }
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2]
              }
            ]
          },
          {
            command: "W",
            commands: [
              {
                command: "fillStyle",
                color: { red: 255, green: 255, blue: 0, alpha: 255 }
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2]
              }
            ]
          }
        ];
      }

      // Main function using the Konekti infrastructure
      function KonektiMain() {
        var client = new Environment();
        Konekti.header("title", "", "Reversi", 3, {
          class: "w3-black w3-center"
        });
        Konekti.raw("log", "The winner is...");
        // Connects the video with the HTML component
        var btn2 = [
          {
            plugin: "raw",
            setup: [
              "time",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf252; Time (secs)",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "size",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf00a; Size",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "W",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf10c; White",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "W_time",
              "&#xf252; White",
              {
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "B",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf111; Black",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "raw",
            setup: [
              "B_time",
              "&#xf252; Black",
              {
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
              }
            ]
          },
          {
            plugin: "btn",
            setup: [
              "play",
              "fa-play",
              "",
              null,
              { title: "Cara", class: "w3-right" }
            ]
          }
        ];
        Konekti.navbar(
          "navbar2",
          btn2,
          { client: "client", method: "play" },
          { class: "w3-black w3-medium" }
        );
        // Connecting the canvas to the HTML component
        var commands = custom_commands();
        Konekti.canvas("canvas", {}, commands, {
          width: "100%",
          height: "fit"
        });
      }
    </script>
  </body>
</html>
